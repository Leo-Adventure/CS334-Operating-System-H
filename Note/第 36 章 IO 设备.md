## 第 36 章 I/O 设备

[TOC]

问题描述：如何将 I/O 集成进计算机系统当中

### 系统架构

一个典型系统的架构：CPU 通过**内存总线（memory bus）**连接到系统的内存，图像或者其他高性能 I/O 设备通过常规的**I/O 总线（I/O bus）**连接到系统。更下面是**外围总线（peripheral bus）**，将最慢的设备连接到系统

为什么要使用分层架构：因为物理布局以及造价成本决定高性能的内存总线没有足够的空间连接太多设备，并且高性能的总线造价非常高。以及便于使得高性能的设备距离 CPU 更近，外围总线连接更多的设备

### 标准设备

一个标准设备包括两部分：

- **硬件接口（interface）**用于让系统软件来控制它的操作。
- **内部结构（internal structure）**：包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。

### 标准协议

一个设备接口包含 3 个寄存器

- **状态**（status）寄存器：用于读取以及查看设备的当前状态
- **命令**（command）寄存器：用于通知设备执行某个具体任务
- **数据**（data）寄存器：将数据传给设备或从设备接收数据

协议步骤：

1. 操作系统反复读取**状态寄存器**，等待设备进入可以接受命令的就绪状态。这个步骤成为轮询（polling）设备
2. 在可以接收命令之后，操作系统下发数据到**数据寄存器**。如果主 CPU 参与数据移动，则称之为编程的 I/O （Programming I/O, PIO）
3. 操作系统将命令写入**命令寄存器**，此时设备将会开始执行命令
4. 操作系统再次通过不断**轮询设备**，等待并且判断设备是否执行完成命令。

关键问题：在操作系统进行轮询的时候，等待设备完成命令时浪费大量的 CPU 时间，需要降低管理设备的 CPU 开销

***

### 利用中断减少 CPU 开销

有了中断之后，操作系统不需要不断轮询设备，而是向设备发送一个请求，然后就可以让对应的进程睡眠，执行其他的任务。当设备完成了自身操作，就会抛出一个硬件中断，引发 CPU 跳转执行操作系统预先定义好的**中断服务例程（Interrupt Service Routine, ISR）**。之后这个例程将会结束之前的请求，并且唤醒等待 I/O 的进程继续执行。

通过使用中断的方式，在进程发出请求等待 I/O 的时候，操作系统便会在 CPU 运行另一个进程，当I/O完成之后，操作系统便会唤醒原有进程，使得 CPU 利用率变高，做到计算与 I/O 的**交叠（overlap）**

但是如果设备运行得非常快，使用中断反而会增加很多切换进程以及中断处理的时间。考虑使用 混合策略（hybrid)，先尝试轮询一段时间，如果设备没有完成操作再使用中断。

### 利用 DMA 进行更高效的==数据传送==

问题描述：当使用编程的 I/O 将一大块数据传给设备（PIO），则 CPU 又会因为这一块数据传输，等待数据拷贝结束之后才能处理其他请求而造成时间算力的浪费。

解决方案：使用**DMA(Direct Memory Access）**,协调完成内存和设备之间的数据传递，不需要 CPU 的介入。

DMA 的工作过程：

1. 操作系统通过**编程**来告诉 DMA 数据位于内存的位置、要拷贝的大小以及要拷贝到哪个设备。
2. 之后，操作系统便会处理其他请求
3. 在 DMA 任务完成之后， DMA 控制器会**抛出中断**来告诉操作系统自己已经完成了数据传输。

### 设备交互

问题描述：解决硬件与设备通信的方式

有两种方式来实现与设备的交互：

1. 使用 **I/O 特权指令**，这些指令规定了操作系统将数据发送到特定设备的方法。

2. **内存映射 I/O**，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载或者存入到该内存地址，然后硬件会其转移到设备上，而不是转移到物理内存。

### 纳入操作系统：设备驱动程序

问题描述：保持操作系统的大部分设备与设备无关，从而对操作系统的主要子系统隐藏设备交互的细节

通过**抽象**解决：在最底层，操作系统的，称为 **设备驱动程序（deviece driver）**的软件封装了所有与设备交互的细节。

文件系统只需要操作通用的通用块层，然后这块设备层会将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作。