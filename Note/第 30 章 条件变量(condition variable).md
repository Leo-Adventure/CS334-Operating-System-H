### 第30章 条件变量(condition variable)

问题描述：提供一种条件满足之后才会执行线程的原语

思路1：使用自旋方案，效率较低

思路2：使用一种类似于队列的条件变量（conditional variable），当条件不满足的时候加入队列，等待条件满足之后被唤醒

两种操作：`wait()` 以及 `signal()`

wait: 释放当前进入的锁，并且使得当前进程进入休眠状态。这两个过程是原子的。

signal: 当条件满足之后，唤醒队列中正在等待的进程。

这两个操作需要伴随着 共享变量以及上锁来完成。否则，就像下面两种情况所示：

1. 没有共享变量。则如果子进程先执行结束，父进程便会由于缺乏唤醒的进程而一直陷入等待状态。即共享变量记录了线程感兴趣的值，当该值符合自己兴趣的时候，便不会再调用 `wait()` 等待
2. 没有上锁。则在父进程即将进入睡眠状态的时候，子进程有可能抢先执行，发出信号，但是此时父进程并没有进入睡眠。之后父进程进入睡眠止呕，无人唤醒。

***

**生产者/消费者问题（producer/consumer）/ 有界缓冲区(bounded buffer)问题**

如果使用 if 来判断进入睡眠的条件而不是使用 while，那么，会出现 Mesa 语义问题（线程发信号只是唤醒等待的线程，告知状态发生了变化，但是并不能保证在被唤醒的线程执行的时候一直保持这种情况）。

**情况1**，假设有两个消费者$T_{C1}, T_{C2}$，$T_{C1}$先执行，发现缓冲区为空，则进入睡眠，等待唤醒。生产者 $T_P$进入执行，给缓冲区补充值之后，调用 `signal()` 唤醒消费者 $T_{C1}$，之后$T_{C1}$准备开始执行，此时消费者 $T_{C2}$抢先执行，由于条件满足，将缓冲区的值消费完了，轮到 $T_{C1}$执行的时候，便会出错。

如果使用 while 而不是 if，则问题会被避免，线程被唤醒之后，依然会检查条件是否满足，不满足将会继续睡眠。

==总之，就是需要使用 `while`来代替 `if`==

**情况2**，假设有两个消费者，并且都处于睡眠状态，一个生产者生产完值之后，唤醒第一个消费者，其中一个消费者消费完缓冲区的值之后，将会执行 `signal`操作，但是不知道唤醒谁，如果此时唤醒了另一个消费者，则两个消费者和生产者都会进入睡眠状态，程序不能正确运行。

==总之，就是需要使用更加有指向性的信号量==

***

**覆盖条件**

考虑分配内存的问题，假设目前没有空闲内存，线程 $T_a$调用了 `allocate(100)`，线程 $T_b$调用了 `allocate(10)`，在线程 $T_c$调用 `free(50)`之后，如果唤醒的是线程 $T_a$，那么都会进入睡眠状态。

此时需要使用一个称为**覆盖条件(covering condition)**的信号量，通过广播唤醒所有等待给信号量的线程使得程序正常运行。

***

